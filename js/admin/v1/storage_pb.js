// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file admin/v1/storage.proto (package admin.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Snapshot, Volume } from "../../api/v1/volume_pb.js";
/**
 * StorageServiceClusterInfoRequest is the request payload for the cluster info request
 *
 * @generated from message admin.v1.StorageServiceClusterInfoRequest
 */
export class StorageServiceClusterInfoRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServiceClusterInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServiceClusterInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServiceClusterInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServiceClusterInfoRequest, a, b);
    }
}
StorageServiceClusterInfoRequest.runtime = proto3;
StorageServiceClusterInfoRequest.typeName = "admin.v1.StorageServiceClusterInfoRequest";
StorageServiceClusterInfoRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "partition", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * StorageServiceClusterInfoResponse is the response payload for the cluster info request
 *
 * @generated from message admin.v1.StorageServiceClusterInfoResponse
 */
export class StorageServiceClusterInfoResponse extends Message {
    constructor(data) {
        super();
        /**
         * Infos about the storage systems
         *
         * @generated from field: repeated admin.v1.StorageClusterInfo infos = 1;
         */
        this.infos = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServiceClusterInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServiceClusterInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServiceClusterInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServiceClusterInfoResponse, a, b);
    }
}
StorageServiceClusterInfoResponse.runtime = proto3;
StorageServiceClusterInfoResponse.typeName = "admin.v1.StorageServiceClusterInfoResponse";
StorageServiceClusterInfoResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "infos", kind: "message", T: StorageClusterInfo, repeated: true },
]);
/**
 * StorageClusterInfo represents details about a storage system
 *
 * @generated from message admin.v1.StorageClusterInfo
 */
export class StorageClusterInfo extends Message {
    constructor(data) {
        super();
        /**
         * Partition where this storage system is present
         *
         * @generated from field: string partition = 1;
         */
        this.partition = "";
        /**
         * Uuid of this storage system
         *
         * @generated from field: string uuid = 2;
         */
        this.uuid = "";
        /**
         * SubsystemNqn is the subsystem nqn
         *
         * @generated from field: string subsystem_nqn = 3;
         */
        this.subsystemNqn = "";
        /**
         * CurrentMaxReplicas defines how many replicas a volume can have currently
         *
         * @generated from field: uint32 current_max_replicas = 4;
         */
        this.currentMaxReplicas = 0;
        /**
         * SupportedMaxReplicas defines how many replicas a volume can have at max
         *
         * @generated from field: uint32 supported_max_replicas = 5;
         */
        this.supportedMaxReplicas = 0;
        /**
         * MinVersionInCluster is the minimum server version in this cluster
         *
         * @generated from field: string min_version_in_cluster = 8;
         */
        this.minVersionInCluster = "";
        /**
         * MinAllowedVersion is the minimum possible server version in this cluster
         *
         * @generated from field: string min_allowed_version = 9;
         */
        this.minAllowedVersion = "";
        /**
         * MaxAllowedVersion is the maximum possible server version in this cluster
         *
         * @generated from field: string max_allowed_version = 10;
         */
        this.maxAllowedVersion = "";
        /**
         * ApiEndpoints is a list of ips of all api endpoints this cluster has
         *
         * @generated from field: repeated string api_endpoints = 11;
         */
        this.apiEndpoints = [];
        /**
         * DiscoveryEndpoints is a list of ips of all discovery endpoints this cluster has
         *
         * @generated from field: repeated string discovery_endpoints = 12;
         */
        this.discoveryEndpoints = [];
        /**
         * Servers is a list of storage servers in this storage system
         *
         * @generated from field: repeated admin.v1.StorageServerInfo servers = 13;
         */
        this.servers = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageClusterInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageClusterInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageClusterInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageClusterInfo, a, b);
    }
}
StorageClusterInfo.runtime = proto3;
StorageClusterInfo.typeName = "admin.v1.StorageClusterInfo";
StorageClusterInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "partition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subsystem_nqn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "current_max_replicas", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "supported_max_replicas", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "statistics", kind: "message", T: ClusterStatisticsApi },
    { no: 7, name: "health", kind: "message", T: ClusterHealth },
    { no: 8, name: "min_version_in_cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "min_allowed_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "max_allowed_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "api_endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "discovery_endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "servers", kind: "message", T: StorageServerInfo, repeated: true },
]);
/**
 * StorageServerInfo contains details about a single storage server
 *
 * @generated from message admin.v1.StorageServerInfo
 */
export class StorageServerInfo extends Message {
    constructor(data) {
        super();
        /**
         * Uuid of this server
         *
         * @generated from field: string uuid = 1;
         */
        this.uuid = "";
        /**
         * Name of this server
         *
         * @generated from field: string name = 2;
         */
        this.name = "";
        /**
         * RiskOfServiceLossState describes the risk of service loss
         *
         * @generated from field: string risk_of_service_loss_state = 3;
         */
        this.riskOfServiceLossState = "";
        /**
         * State of this server
         *
         * @generated from field: string state = 4;
         */
        this.state = "";
        /**
         * ServerEndpoints is a list of ips this server offers
         *
         * @generated from field: repeated string server_endpoints = 5;
         */
        this.serverEndpoints = [];
        /**
         * LightOsVersion is the version of the storage server version
         *
         * @generated from field: string light_os_version = 6;
         */
        this.lightOsVersion = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServerInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServerInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServerInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServerInfo, a, b);
    }
}
StorageServerInfo.runtime = proto3;
StorageServerInfo.typeName = "admin.v1.StorageServerInfo";
StorageServerInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "risk_of_service_loss_state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "server_endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "light_os_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * ClusterHealth the healt of the cluster
 *
 * @generated from message admin.v1.ClusterHealth
 */
export class ClusterHealth extends Message {
    constructor(data) {
        super();
        /**
         * State of the cluster
         *
         * @generated from field: string state = 1;
         */
        this.state = "";
        /**
         * NumDegradedVolumes is the number of degraded volumes
         *
         * @generated from field: uint32 num_degraded_volumes = 2;
         */
        this.numDegradedVolumes = 0;
        /**
         * NumReadonlyVolumes is the number of read only volumes
         *
         * @generated from field: uint32 num_read_only_volumes = 3;
         */
        this.numReadOnlyVolumes = 0;
        /**
         * NumNotAvailableVolumes is the number of not available volumes
         *
         * @generated from field: uint32 num_not_available_volumes = 4;
         */
        this.numNotAvailableVolumes = 0;
        /**
         * NumInactiveVolumes is the number of inactive volumes
         *
         * @generated from field: uint32 num_inactive_nodes = 5;
         */
        this.numInactiveNodes = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ClusterHealth().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClusterHealth().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClusterHealth().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ClusterHealth, a, b);
    }
}
ClusterHealth.runtime = proto3;
ClusterHealth.typeName = "admin.v1.ClusterHealth";
ClusterHealth.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "num_degraded_volumes", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "num_read_only_volumes", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "num_not_available_volumes", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "num_inactive_nodes", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * ClusterStatisticsApi detailed statistics of the storage cluster
 *
 * @generated from message admin.v1.ClusterStatisticsApi
 */
export class ClusterStatisticsApi extends Message {
    constructor(data) {
        super();
        /**
         * Installed Physical Storage
         *
         * All installed SSDs capacities over all servers in cluster, given in bytes.
         *
         * @generated from field: uint64 installed_physical_storage = 1;
         */
        this.installedPhysicalStorage = protoInt64.zero;
        /**
         * Total Attached Physical Storage
         *
         * Sum of all managed and healthy SSDs capacities, given in bytes.
         *
         * @generated from field: uint64 managed_physical_storage = 2;
         */
        this.managedPhysicalStorage = protoInt64.zero;
        /**
         * Effective Physical Storage
         *
         * Effective Physical storage excluding overhead of OVP and Parity, given in bytes.
         *
         * @generated from field: uint64 effective_physical_storage = 3;
         */
        this.effectivePhysicalStorage = protoInt64.zero;
        /**
         * Logical Storage
         *
         * Sum of capacities of all allocated volumes, given in bytes.
         *
         * @generated from field: uint64 logical_storage = 4;
         */
        this.logicalStorage = protoInt64.zero;
        /**
         * Logical Used Storage
         *
         * Logical storage space used by all volumes (n of LBAs x 4096), given in bytes.
         *
         * @generated from field: uint64 logical_used_storage = 5;
         */
        this.logicalUsedStorage = protoInt64.zero;
        /**
         * Physical Used Storage Excluding Parity
         *
         * Physical storage space occupied by all volumes (data only), given in bytes.
         *
         * @generated from field: uint64 physical_used_storage = 6;
         */
        this.physicalUsedStorage = protoInt64.zero;
        /**
         * Physical Used Storage
         *
         * Physical storage space occupied by all data including Parity overhead when EC enabled (physical n*disks/(n*disks -1)), given in bytes.
         *
         * @generated from field: uint64 physical_used_storage_including_parity = 7;
         */
        this.physicalUsedStorageIncludingParity = protoInt64.zero;
        /**
         * Free Physical Storage
         *
         * Free storage before entering to read-only mode , given in bytes.
         *
         * @generated from field: uint64 free_physical_storage = 8;
         */
        this.freePhysicalStorage = protoInt64.zero;
        /**
         * Estimated Free Logical Storage
         *
         * Estimated free storage before entering to read-only mode assuming current compression ratio, given in bytes.
         *
         * @generated from field: uint64 estimated_free_logical_storage = 9;
         */
        this.estimatedFreeLogicalStorage = protoInt64.zero;
        /**
         * Estimated Total Available Logical Storage
         *
         * Estimate of total available logical storage based on current compression ratio (effective * compression)
         *
         * @generated from field: uint64 estimated_logical_storage = 10;
         */
        this.estimatedLogicalStorage = protoInt64.zero;
        /**
         * compression ratio
         *
         * compression ratio logicalUsedStorage/physicalUsedStorage
         *
         * @generated from field: double compression_ratio = 11;
         */
        this.compressionRatio = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ClusterStatisticsApi().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClusterStatisticsApi().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClusterStatisticsApi().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ClusterStatisticsApi, a, b);
    }
}
ClusterStatisticsApi.runtime = proto3;
ClusterStatisticsApi.typeName = "admin.v1.ClusterStatisticsApi";
ClusterStatisticsApi.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "installed_physical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "managed_physical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "effective_physical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "logical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "logical_used_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "physical_used_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "physical_used_storage_including_parity", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "free_physical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "estimated_free_logical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "estimated_logical_storage", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "compression_ratio", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
]);
/**
 * StorageServiceListVolumesRequest is the request payload for the volume list request
 *
 * @generated from message admin.v1.StorageServiceListVolumesRequest
 */
export class StorageServiceListVolumesRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServiceListVolumesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServiceListVolumesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServiceListVolumesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServiceListVolumesRequest, a, b);
    }
}
StorageServiceListVolumesRequest.runtime = proto3;
StorageServiceListVolumesRequest.typeName = "admin.v1.StorageServiceListVolumesRequest";
StorageServiceListVolumesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "project", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "partition", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "tenant", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * StorageServiceListVolumesResponse is the response payload for the volume list request
 *
 * @generated from message admin.v1.StorageServiceListVolumesResponse
 */
export class StorageServiceListVolumesResponse extends Message {
    constructor(data) {
        super();
        /**
         * Volumes is the list of volumes
         *
         * @generated from field: repeated api.v1.Volume volumes = 1;
         */
        this.volumes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServiceListVolumesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServiceListVolumesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServiceListVolumesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServiceListVolumesResponse, a, b);
    }
}
StorageServiceListVolumesResponse.runtime = proto3;
StorageServiceListVolumesResponse.typeName = "admin.v1.StorageServiceListVolumesResponse";
StorageServiceListVolumesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "volumes", kind: "message", T: Volume, repeated: true },
]);
/**
 * StorageServiceListVolumesRequest is the request payload for the snapshot list request
 *
 * @generated from message admin.v1.StorageServiceListSnapshotsRequest
 */
export class StorageServiceListSnapshotsRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServiceListSnapshotsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServiceListSnapshotsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServiceListSnapshotsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServiceListSnapshotsRequest, a, b);
    }
}
StorageServiceListSnapshotsRequest.runtime = proto3;
StorageServiceListSnapshotsRequest.typeName = "admin.v1.StorageServiceListSnapshotsRequest";
StorageServiceListSnapshotsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "project", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "partition", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "tenant", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * StorageServiceListSnapshotsResponse is the response payload for the snapshot list request
 *
 * @generated from message admin.v1.StorageServiceListSnapshotsResponse
 */
export class StorageServiceListSnapshotsResponse extends Message {
    constructor(data) {
        super();
        /**
         * Snapshots is the list of snapshots
         *
         * @generated from field: repeated api.v1.Snapshot snapshots = 1;
         */
        this.snapshots = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StorageServiceListSnapshotsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StorageServiceListSnapshotsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StorageServiceListSnapshotsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StorageServiceListSnapshotsResponse, a, b);
    }
}
StorageServiceListSnapshotsResponse.runtime = proto3;
StorageServiceListSnapshotsResponse.typeName = "admin.v1.StorageServiceListSnapshotsResponse";
StorageServiceListSnapshotsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "snapshots", kind: "message", T: Snapshot, repeated: true },
]);
