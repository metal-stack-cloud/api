// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/v1/payment.proto

package apiv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PaymentCustomer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PaymentCustomer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentCustomer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaymentCustomerMultiError, or nil if none found.
func (m *PaymentCustomer) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentCustomer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Login

	// no validation rules for PaymentMethodId

	// no validation rules for SubscriptionId

	for idx, item := range m.GetPrices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentCustomerValidationError{
						field:  fmt.Sprintf("Prices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentCustomerValidationError{
						field:  fmt.Sprintf("Prices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentCustomerValidationError{
					field:  fmt.Sprintf("Prices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentCustomerValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentCustomerValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentCustomerValidationError{
				field:  "Address",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.CustomerId != nil {
		// no validation rules for CustomerId
	}

	if m.Email != nil {
		// no validation rules for Email
	}

	if m.Card != nil {

		if all {
			switch v := interface{}(m.GetCard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaymentCustomerValidationError{
						field:  "Card",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaymentCustomerValidationError{
						field:  "Card",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaymentCustomerValidationError{
					field:  "Card",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PaymentCustomerMultiError(errors)
	}

	return nil
}

// PaymentCustomerMultiError is an error wrapping multiple validation errors
// returned by PaymentCustomer.ValidateAll() if the designated constraints
// aren't met.
type PaymentCustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentCustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentCustomerMultiError) AllErrors() []error { return m }

// PaymentCustomerValidationError is the validation error returned by
// PaymentCustomer.Validate if the designated constraints aren't met.
type PaymentCustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentCustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentCustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentCustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentCustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentCustomerValidationError) ErrorName() string { return "PaymentCustomerValidationError" }

// Error satisfies the builtin error interface
func (e PaymentCustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentCustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentCustomerValidationError{}

// Validate checks the field values on Card with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Card) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Card with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CardMultiError, or nil if none found.
func (m *Card) ValidateAll() error {
	return m.validate(true)
}

func (m *Card) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Brand

	// no validation rules for Country

	// no validation rules for ExpMonth

	// no validation rules for ExpYear

	// no validation rules for Last_4

	if len(errors) > 0 {
		return CardMultiError(errors)
	}

	return nil
}

// CardMultiError is an error wrapping multiple validation errors returned by
// Card.ValidateAll() if the designated constraints aren't met.
type CardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardMultiError) AllErrors() []error { return m }

// CardValidationError is the validation error returned by Card.Validate if the
// designated constraints aren't met.
type CardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardValidationError) ErrorName() string { return "CardValidationError" }

// Error satisfies the builtin error interface
func (e CardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardValidationError{}

// Validate checks the field values on Price with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Price) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Price with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PriceMultiError, or nil if none found.
func (m *Price) ValidateAll() error {
	return m.validate(true)
}

func (m *Price) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for UnitAmountDecimal

	// no validation rules for Currency

	if len(errors) > 0 {
		return PriceMultiError(errors)
	}

	return nil
}

// PriceMultiError is an error wrapping multiple validation errors returned by
// Price.ValidateAll() if the designated constraints aren't met.
type PriceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PriceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PriceMultiError) AllErrors() []error { return m }

// PriceValidationError is the validation error returned by Price.Validate if
// the designated constraints aren't met.
type PriceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PriceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PriceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PriceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PriceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PriceValidationError) ErrorName() string { return "PriceValidationError" }

// Error satisfies the builtin error interface
func (e PriceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PriceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PriceValidationError{}

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Address) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddressMultiError, or nil if none found.
func (m *Address) ValidateAll() error {
	return m.validate(true)
}

func (m *Address) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Line1

	// no validation rules for Line2

	// no validation rules for PostalCode

	// no validation rules for City

	// no validation rules for State

	// no validation rules for Country

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}

	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.ValidateAll() if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on
// PaymentServiceCreateOrUpdateCustomerRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceCreateOrUpdateCustomerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceCreateOrUpdateCustomerRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceCreateOrUpdateCustomerRequestMultiError, or nil if none found.
func (m *PaymentServiceCreateOrUpdateCustomerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceCreateOrUpdateCustomerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCustomer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentServiceCreateOrUpdateCustomerRequestValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentServiceCreateOrUpdateCustomerRequestValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentServiceCreateOrUpdateCustomerRequestValidationError{
				field:  "Customer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaymentServiceCreateOrUpdateCustomerRequestMultiError(errors)
	}

	return nil
}

// PaymentServiceCreateOrUpdateCustomerRequestMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceCreateOrUpdateCustomerRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceCreateOrUpdateCustomerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceCreateOrUpdateCustomerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceCreateOrUpdateCustomerRequestMultiError) AllErrors() []error { return m }

// PaymentServiceCreateOrUpdateCustomerRequestValidationError is the validation
// error returned by PaymentServiceCreateOrUpdateCustomerRequest.Validate if
// the designated constraints aren't met.
type PaymentServiceCreateOrUpdateCustomerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceCreateOrUpdateCustomerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceCreateOrUpdateCustomerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceCreateOrUpdateCustomerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceCreateOrUpdateCustomerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceCreateOrUpdateCustomerRequestValidationError) ErrorName() string {
	return "PaymentServiceCreateOrUpdateCustomerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceCreateOrUpdateCustomerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceCreateOrUpdateCustomerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceCreateOrUpdateCustomerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceCreateOrUpdateCustomerRequestValidationError{}

// Validate checks the field values on
// PaymentServiceCreateOrUpdateCustomerResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceCreateOrUpdateCustomerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceCreateOrUpdateCustomerResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceCreateOrUpdateCustomerResponseMultiError, or nil if none found.
func (m *PaymentServiceCreateOrUpdateCustomerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceCreateOrUpdateCustomerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCustomer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentServiceCreateOrUpdateCustomerResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentServiceCreateOrUpdateCustomerResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentServiceCreateOrUpdateCustomerResponseValidationError{
				field:  "Customer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaymentServiceCreateOrUpdateCustomerResponseMultiError(errors)
	}

	return nil
}

// PaymentServiceCreateOrUpdateCustomerResponseMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceCreateOrUpdateCustomerResponse.ValidateAll() if the
// designated constraints aren't met.
type PaymentServiceCreateOrUpdateCustomerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceCreateOrUpdateCustomerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceCreateOrUpdateCustomerResponseMultiError) AllErrors() []error { return m }

// PaymentServiceCreateOrUpdateCustomerResponseValidationError is the
// validation error returned by
// PaymentServiceCreateOrUpdateCustomerResponse.Validate if the designated
// constraints aren't met.
type PaymentServiceCreateOrUpdateCustomerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceCreateOrUpdateCustomerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceCreateOrUpdateCustomerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceCreateOrUpdateCustomerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceCreateOrUpdateCustomerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceCreateOrUpdateCustomerResponseValidationError) ErrorName() string {
	return "PaymentServiceCreateOrUpdateCustomerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceCreateOrUpdateCustomerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceCreateOrUpdateCustomerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceCreateOrUpdateCustomerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceCreateOrUpdateCustomerResponseValidationError{}

// Validate checks the field values on PaymentServiceGetCustomerRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PaymentServiceGetCustomerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentServiceGetCustomerRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PaymentServiceGetCustomerRequestMultiError, or nil if none found.
func (m *PaymentServiceGetCustomerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceGetCustomerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomerId

	if len(errors) > 0 {
		return PaymentServiceGetCustomerRequestMultiError(errors)
	}

	return nil
}

// PaymentServiceGetCustomerRequestMultiError is an error wrapping multiple
// validation errors returned by
// PaymentServiceGetCustomerRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceGetCustomerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceGetCustomerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceGetCustomerRequestMultiError) AllErrors() []error { return m }

// PaymentServiceGetCustomerRequestValidationError is the validation error
// returned by PaymentServiceGetCustomerRequest.Validate if the designated
// constraints aren't met.
type PaymentServiceGetCustomerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceGetCustomerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceGetCustomerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceGetCustomerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceGetCustomerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceGetCustomerRequestValidationError) ErrorName() string {
	return "PaymentServiceGetCustomerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceGetCustomerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceGetCustomerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceGetCustomerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceGetCustomerRequestValidationError{}

// Validate checks the field values on PaymentServiceGetCustomerResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PaymentServiceGetCustomerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentServiceGetCustomerResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PaymentServiceGetCustomerResponseMultiError, or nil if none found.
func (m *PaymentServiceGetCustomerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceGetCustomerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCustomer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentServiceGetCustomerResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentServiceGetCustomerResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentServiceGetCustomerResponseValidationError{
				field:  "Customer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaymentServiceGetCustomerResponseMultiError(errors)
	}

	return nil
}

// PaymentServiceGetCustomerResponseMultiError is an error wrapping multiple
// validation errors returned by
// PaymentServiceGetCustomerResponse.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceGetCustomerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceGetCustomerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceGetCustomerResponseMultiError) AllErrors() []error { return m }

// PaymentServiceGetCustomerResponseValidationError is the validation error
// returned by PaymentServiceGetCustomerResponse.Validate if the designated
// constraints aren't met.
type PaymentServiceGetCustomerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceGetCustomerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceGetCustomerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceGetCustomerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceGetCustomerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceGetCustomerResponseValidationError) ErrorName() string {
	return "PaymentServiceGetCustomerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceGetCustomerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceGetCustomerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceGetCustomerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceGetCustomerResponseValidationError{}

// Validate checks the field values on
// PaymentServiceGetCustomerWithLoginRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceGetCustomerWithLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceGetCustomerWithLoginRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceGetCustomerWithLoginRequestMultiError, or nil if none found.
func (m *PaymentServiceGetCustomerWithLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceGetCustomerWithLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Login

	if len(errors) > 0 {
		return PaymentServiceGetCustomerWithLoginRequestMultiError(errors)
	}

	return nil
}

// PaymentServiceGetCustomerWithLoginRequestMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceGetCustomerWithLoginRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceGetCustomerWithLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceGetCustomerWithLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceGetCustomerWithLoginRequestMultiError) AllErrors() []error { return m }

// PaymentServiceGetCustomerWithLoginRequestValidationError is the validation
// error returned by PaymentServiceGetCustomerWithLoginRequest.Validate if the
// designated constraints aren't met.
type PaymentServiceGetCustomerWithLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceGetCustomerWithLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceGetCustomerWithLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceGetCustomerWithLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceGetCustomerWithLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceGetCustomerWithLoginRequestValidationError) ErrorName() string {
	return "PaymentServiceGetCustomerWithLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceGetCustomerWithLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceGetCustomerWithLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceGetCustomerWithLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceGetCustomerWithLoginRequestValidationError{}

// Validate checks the field values on
// PaymentServiceGetCustomerWithLoginResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceGetCustomerWithLoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceGetCustomerWithLoginResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceGetCustomerWithLoginResponseMultiError, or nil if none found.
func (m *PaymentServiceGetCustomerWithLoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceGetCustomerWithLoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCustomer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentServiceGetCustomerWithLoginResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentServiceGetCustomerWithLoginResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentServiceGetCustomerWithLoginResponseValidationError{
				field:  "Customer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaymentServiceGetCustomerWithLoginResponseMultiError(errors)
	}

	return nil
}

// PaymentServiceGetCustomerWithLoginResponseMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceGetCustomerWithLoginResponse.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceGetCustomerWithLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceGetCustomerWithLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceGetCustomerWithLoginResponseMultiError) AllErrors() []error { return m }

// PaymentServiceGetCustomerWithLoginResponseValidationError is the validation
// error returned by PaymentServiceGetCustomerWithLoginResponse.Validate if
// the designated constraints aren't met.
type PaymentServiceGetCustomerWithLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceGetCustomerWithLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceGetCustomerWithLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceGetCustomerWithLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceGetCustomerWithLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceGetCustomerWithLoginResponseValidationError) ErrorName() string {
	return "PaymentServiceGetCustomerWithLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceGetCustomerWithLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceGetCustomerWithLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceGetCustomerWithLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceGetCustomerWithLoginResponseValidationError{}

// Validate checks the field values on
// PaymentServiceCheckIfCustomerExistsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceCheckIfCustomerExistsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceCheckIfCustomerExistsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceCheckIfCustomerExistsRequestMultiError, or nil if none found.
func (m *PaymentServiceCheckIfCustomerExistsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceCheckIfCustomerExistsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Login

	if len(errors) > 0 {
		return PaymentServiceCheckIfCustomerExistsRequestMultiError(errors)
	}

	return nil
}

// PaymentServiceCheckIfCustomerExistsRequestMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceCheckIfCustomerExistsRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceCheckIfCustomerExistsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceCheckIfCustomerExistsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceCheckIfCustomerExistsRequestMultiError) AllErrors() []error { return m }

// PaymentServiceCheckIfCustomerExistsRequestValidationError is the validation
// error returned by PaymentServiceCheckIfCustomerExistsRequest.Validate if
// the designated constraints aren't met.
type PaymentServiceCheckIfCustomerExistsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceCheckIfCustomerExistsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceCheckIfCustomerExistsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceCheckIfCustomerExistsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceCheckIfCustomerExistsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceCheckIfCustomerExistsRequestValidationError) ErrorName() string {
	return "PaymentServiceCheckIfCustomerExistsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceCheckIfCustomerExistsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceCheckIfCustomerExistsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceCheckIfCustomerExistsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceCheckIfCustomerExistsRequestValidationError{}

// Validate checks the field values on
// PaymentServiceCheckIfCustomerExistsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceCheckIfCustomerExistsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceCheckIfCustomerExistsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceCheckIfCustomerExistsResponseMultiError, or nil if none found.
func (m *PaymentServiceCheckIfCustomerExistsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceCheckIfCustomerExistsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCustomer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentServiceCheckIfCustomerExistsResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentServiceCheckIfCustomerExistsResponseValidationError{
					field:  "Customer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentServiceCheckIfCustomerExistsResponseValidationError{
				field:  "Customer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Exists

	if len(errors) > 0 {
		return PaymentServiceCheckIfCustomerExistsResponseMultiError(errors)
	}

	return nil
}

// PaymentServiceCheckIfCustomerExistsResponseMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceCheckIfCustomerExistsResponse.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceCheckIfCustomerExistsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceCheckIfCustomerExistsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceCheckIfCustomerExistsResponseMultiError) AllErrors() []error { return m }

// PaymentServiceCheckIfCustomerExistsResponseValidationError is the validation
// error returned by PaymentServiceCheckIfCustomerExistsResponse.Validate if
// the designated constraints aren't met.
type PaymentServiceCheckIfCustomerExistsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceCheckIfCustomerExistsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceCheckIfCustomerExistsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceCheckIfCustomerExistsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceCheckIfCustomerExistsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceCheckIfCustomerExistsResponseValidationError) ErrorName() string {
	return "PaymentServiceCheckIfCustomerExistsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceCheckIfCustomerExistsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceCheckIfCustomerExistsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceCheckIfCustomerExistsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceCheckIfCustomerExistsResponseValidationError{}

// Validate checks the field values on PaymentServiceHasPaymentMethodRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *PaymentServiceHasPaymentMethodRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentServiceHasPaymentMethodRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PaymentServiceHasPaymentMethodRequestMultiError, or nil if none found.
func (m *PaymentServiceHasPaymentMethodRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceHasPaymentMethodRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLogin()); l < 2 || l > 128 {
		err := PaymentServiceHasPaymentMethodRequestValidationError{
			field:  "Login",
			reason: "value length must be between 2 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProject()); l < 2 || l > 128 {
		err := PaymentServiceHasPaymentMethodRequestValidationError{
			field:  "Project",
			reason: "value length must be between 2 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PaymentServiceHasPaymentMethodRequestMultiError(errors)
	}

	return nil
}

// PaymentServiceHasPaymentMethodRequestMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceHasPaymentMethodRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceHasPaymentMethodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceHasPaymentMethodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceHasPaymentMethodRequestMultiError) AllErrors() []error { return m }

// PaymentServiceHasPaymentMethodRequestValidationError is the validation error
// returned by PaymentServiceHasPaymentMethodRequest.Validate if the
// designated constraints aren't met.
type PaymentServiceHasPaymentMethodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceHasPaymentMethodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceHasPaymentMethodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceHasPaymentMethodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceHasPaymentMethodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceHasPaymentMethodRequestValidationError) ErrorName() string {
	return "PaymentServiceHasPaymentMethodRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceHasPaymentMethodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceHasPaymentMethodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceHasPaymentMethodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceHasPaymentMethodRequestValidationError{}

// Validate checks the field values on PaymentServiceHasPaymentMethodResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *PaymentServiceHasPaymentMethodResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceHasPaymentMethodResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// PaymentServiceHasPaymentMethodResponseMultiError, or nil if none found.
func (m *PaymentServiceHasPaymentMethodResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceHasPaymentMethodResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exists

	if len(errors) > 0 {
		return PaymentServiceHasPaymentMethodResponseMultiError(errors)
	}

	return nil
}

// PaymentServiceHasPaymentMethodResponseMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceHasPaymentMethodResponse.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceHasPaymentMethodResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceHasPaymentMethodResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceHasPaymentMethodResponseMultiError) AllErrors() []error { return m }

// PaymentServiceHasPaymentMethodResponseValidationError is the validation
// error returned by PaymentServiceHasPaymentMethodResponse.Validate if the
// designated constraints aren't met.
type PaymentServiceHasPaymentMethodResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceHasPaymentMethodResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceHasPaymentMethodResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceHasPaymentMethodResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceHasPaymentMethodResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceHasPaymentMethodResponseValidationError) ErrorName() string {
	return "PaymentServiceHasPaymentMethodResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceHasPaymentMethodResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceHasPaymentMethodResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceHasPaymentMethodResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceHasPaymentMethodResponseValidationError{}

// Validate checks the field values on PaymentServiceDeletePaymentMethodRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *PaymentServiceDeletePaymentMethodRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceDeletePaymentMethodRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceDeletePaymentMethodRequestMultiError, or nil if none found.
func (m *PaymentServiceDeletePaymentMethodRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceDeletePaymentMethodRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLogin()); l < 2 || l > 128 {
		err := PaymentServiceDeletePaymentMethodRequestValidationError{
			field:  "Login",
			reason: "value length must be between 2 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PaymentServiceDeletePaymentMethodRequestMultiError(errors)
	}

	return nil
}

// PaymentServiceDeletePaymentMethodRequestMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceDeletePaymentMethodRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceDeletePaymentMethodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceDeletePaymentMethodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceDeletePaymentMethodRequestMultiError) AllErrors() []error { return m }

// PaymentServiceDeletePaymentMethodRequestValidationError is the validation
// error returned by PaymentServiceDeletePaymentMethodRequest.Validate if the
// designated constraints aren't met.
type PaymentServiceDeletePaymentMethodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceDeletePaymentMethodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceDeletePaymentMethodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceDeletePaymentMethodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceDeletePaymentMethodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceDeletePaymentMethodRequestValidationError) ErrorName() string {
	return "PaymentServiceDeletePaymentMethodRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceDeletePaymentMethodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceDeletePaymentMethodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceDeletePaymentMethodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceDeletePaymentMethodRequestValidationError{}

// Validate checks the field values on
// PaymentServiceDeletePaymentMethodResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PaymentServiceDeletePaymentMethodResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentServiceDeletePaymentMethodResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentServiceDeletePaymentMethodResponseMultiError, or nil if none found.
func (m *PaymentServiceDeletePaymentMethodResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentServiceDeletePaymentMethodResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PaymentServiceDeletePaymentMethodResponseMultiError(errors)
	}

	return nil
}

// PaymentServiceDeletePaymentMethodResponseMultiError is an error wrapping
// multiple validation errors returned by
// PaymentServiceDeletePaymentMethodResponse.ValidateAll() if the designated
// constraints aren't met.
type PaymentServiceDeletePaymentMethodResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentServiceDeletePaymentMethodResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentServiceDeletePaymentMethodResponseMultiError) AllErrors() []error { return m }

// PaymentServiceDeletePaymentMethodResponseValidationError is the validation
// error returned by PaymentServiceDeletePaymentMethodResponse.Validate if the
// designated constraints aren't met.
type PaymentServiceDeletePaymentMethodResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentServiceDeletePaymentMethodResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentServiceDeletePaymentMethodResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentServiceDeletePaymentMethodResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentServiceDeletePaymentMethodResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentServiceDeletePaymentMethodResponseValidationError) ErrorName() string {
	return "PaymentServiceDeletePaymentMethodResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentServiceDeletePaymentMethodResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentServiceDeletePaymentMethodResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentServiceDeletePaymentMethodResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentServiceDeletePaymentMethodResponseValidationError{}
